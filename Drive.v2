#include <Servo.h>

Servo servoLeft;
Servo servoRight;
int oldLeftVelocity = 0;
int oldRightVelocity = 0;
int accelDuration;
int accelSteps;

//----------Accelerera och kör hjul----------
void Drive(int leftVelocity, int rightVelocity, int duration) {

  accelDuration = 1000; //Tid som accelerationen pågår
  if (duration < accelDuration) {
    accelDuration = duration; //Snabba upp acceleration om den valda tiden är för kort
  }
  accelSteps = 20; //Antal accelerationssteg

  //Hastightetsökning per acceletationssteg
  float leftAccelStep = ((1500.00 + leftVelocity) - (1500.00 + oldLeftVelocity)) / accelSteps;
  float rightAccelStep = ((1500.00 - rightVelocity) - (1500.00 - oldRightVelocity)) / accelSteps;

  //Accelerationsloop. Ökar den gamla farten till den nya och skriver ut värdena i två kolumner
  for (int i = 0; i < accelSteps; i++) {
    servoLeft.writeMicroseconds(1500 + oldLeftVelocity + leftAccelStep * i);
    Serial.print(1500 + oldLeftVelocity + leftAccelStep * i);
    Serial.print("     ");
    servoRight.writeMicroseconds(1500 - oldRightVelocity + rightAccelStep * i);
    Serial.println(1500 - oldRightVelocity + rightAccelStep * i);
    delay(accelDuration / accelSteps); // Fördröjningen mellan varje fartökning
  }

  //Om accelerationsloppen inte träffar exakt rätt pga avrundning
  servoLeft.writeMicroseconds(1500 + leftVelocity);
  Serial.print(1500 + leftVelocity);
  Serial.print("        ");
  servoRight.writeMicroseconds(1500 - rightVelocity);
  Serial.println(1500 - rightVelocity);
  Serial.println();

  delay(duration - accelDuration); //Tid på full fart

  oldLeftVelocity = leftVelocity;
  oldRightVelocity = rightVelocity;

  //tone(4, 3000, 200); //Ton vid hastighetsändring
}

//Funktion för svängar
void Turn(int angle, String rightorleft, String hardorsoft){ //Ange vinkel och riktning(antingen "right" eller "left")
  int speedangle = 1.5 * angle; //Hastighet beroende på vinkel. Ändra på "x * angle" för att kalibrera
  float differancefactor = 0.92; //Anpassning för skillnad i hastighet (just nu ska vänstersvängar vara långsammare)
  float turntimefactor = 13; //Använd för att kalibrera totaltiden vid mjuka svängar
  int wrongwheelspeed = 0; //Vid mjuka svängar ska ett hjul gå mot 0rpm
  
  if (speedangle > 100){ //Låter ej hastighet överstiga 100
    speedangle = 100;
  }
  if(angle > 300){ //Minskar skillnad i hastighet vid höga vinklar
    differancefactor = 0.96;
  }
  if(hardorsoft == "hard"){
    Drive(0, 0, 500); //Stannar för att få en skarp sväng
    turntimefactor = 5.7; //Ändrar totaltiden för hårda svängar
    wrongwheelspeed = -speedangle; //Vid hårda svängar ska ett hjul gå mot negativt det andra hjulets rpm
  }
  if(rightorleft == "right"){
    Drive(speedangle, wrongwheelspeed, turntimefactor*angle);
    Drive(0, 0, turntimefactor*angle);   
  }
  else if (rightorleft == "left"){
    Drive(wrongwheelspeed * differancefactor, speedangle * differancefactor, turntimefactor*angle);
    Drive(0, 0, turntimefactor*angle);   
  }   
}

void setup() {

  Serial.begin(9600);

  //Startton
  tone(4, 200, 500);
  delay(2000);

  servoLeft.attach(11);
  servoRight.attach(12);

//Drive-funktionen:
  //Fart vänster hjul, hastighet höger hjul, tid
  //Minsta tid är ca. 500. Antagligen pga hårdvarubegränsningar
  //Max rekomenderad hastighet är 100 (1600 respektive 1400) pga att det det änder så pass lite mellan 100 och 200

//Turn-funktionen:
  //Vinkel (grader), "right" eller "left" (med citattecken), "hard" eller "soft" (med citattecken)
  //Högre vinklar än 360 rekomenderas ej (det är också onödigt)
  //Se till att kalibrera svängarna utifrån skillnad i hastighet mellan hjulen

  Drive(100, 100, 200);
  Turn(90, "left", "soft");
  Drive(100, 100, 2500);
  Turn(180, "left", "hard");
  Drive(100, 100, 2500);
  Drive(0, 0, 500);

  tone(4, 200, 600); //Slutton

}

void loop() {

}
